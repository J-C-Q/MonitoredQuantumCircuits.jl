import{_ as e,c as a,o as i,a7 as s}from"./chunks/framework.CKROT6r-.js";const y=JSON.parse('{"title":"How to add a new backend?","description":"","frontmatter":{},"headers":[],"relativePath":"add_backend.md","filePath":"add_backend.md","lastUpdated":null}'),t={name:"add_backend.md"},n=s(`<h1 id="How-to-add-a-new-backend?" tabindex="-1">How to add a new backend? <a class="header-anchor" href="#How-to-add-a-new-backend?" aria-label="Permalink to &quot;How to add a new backend? {#How-to-add-a-new-backend?}&quot;">​</a></h1><p>MonitoredQuantumCircuits.jl allows you to add further backends, be it simulators or quantum devices. In general, it is recommended to create a module for each backend and import the necessary methods and types from MonitoredQuantumCircuits.jl into the name space.</p><h2 id="Create-a-backend-type" tabindex="-1">Create a backend type <a class="header-anchor" href="#Create-a-backend-type" aria-label="Permalink to &quot;Create a backend type {#Create-a-backend-type}&quot;">​</a></h2><p>The first step is to create a type <code>MyBackend&lt;:Simulator</code> if your backend is a simulator or <code>MyBackend&lt;:QuantumComputer</code> if your backend is a quantum device. This type does not have to contain any attributes (it can if that is necessary for your backend), but is solely used for dispatching the <code>execute</code> function.</p><h2 id="Create-a-quantum-circuit-type" tabindex="-1">Create a quantum circuit type <a class="header-anchor" href="#Create-a-quantum-circuit-type" aria-label="Permalink to &quot;Create a quantum circuit type {#Create-a-quantum-circuit-type}&quot;">​</a></h2><p>The second step is to implement a type for a quantum circuit (e.g. <code>MyCircuit</code>) in the specific backend. This type stores all the information the backend execution needs to execute your quantum circuit and is used to dispatch the <code>apply!</code> method for each operation.</p><h2 id="Create-apply!-methods" tabindex="-1">Create <code>apply!</code> methods <a class="header-anchor" href="#Create-apply!-methods" aria-label="Permalink to &quot;Create \`apply!\` methods {#Create-apply!-methods}&quot;">​</a></h2><p>Next, you need to implement the <code>apply!</code> methods for every operation that your backend should support. For example, for the <code>H</code> (Hadamard) operation, this could look like this</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> apply!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyCircuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">H</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # logic goes here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>For the <code>ZZ</code> (parity measurement) this could look like this</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> apply!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyCircuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ZZ</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # logic goes here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><h2 id="Implement-the-execute-method" tabindex="-1">Implement the <code>execute</code> method <a class="header-anchor" href="#Implement-the-execute-method" aria-label="Permalink to &quot;Implement the \`execute\` method {#Implement-the-execute-method}&quot;">​</a></h2><p>Lastly, you have to implement a method that handles the execution (i.e. simulation or API requests to the quantum device).</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FiniteDepthCircuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MyBackend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # logic goes here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>This function should create an object of type <code>MyCircuit</code> and apply the gates from <code>circuit</code> using the implemented <code>apply!</code> methods. Of course, you need to do this for every circuit type that you want to support with your backend.</p>`,15),h=[n];function p(d,l,o,r,c,k){return i(),a("div",null,h)}const m=e(t,[["render",p]]);export{y as __pageData,m as default};
