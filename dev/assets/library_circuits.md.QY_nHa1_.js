import{_ as i,c as t,o as e,a7 as a}from"./chunks/framework.Ck1NKG2X.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"library/circuits.md","filePath":"library/circuits.md","lastUpdated":null}'),s={name:"library/circuits.md"},r=a('<h2 id="circuit" tabindex="-1">Circuit <a class="header-anchor" href="#circuit" aria-label="Permalink to &quot;Circuit&quot;">​</a></h2><p>A circuit represents the operations being applied to the qubits in a lattice. As of now, there are two types of circuits</p><ul><li><p><code>FiniteDepthCircuit</code></p></li><li><p><code>RandomCircuit</code></p></li></ul><h3 id="finitedepthcircuit" tabindex="-1">FiniteDepthCircuit <a class="header-anchor" href="#finitedepthcircuit" aria-label="Permalink to &quot;FiniteDepthCircuit&quot;">​</a></h3><p>This type of circuit stores an explicit representation of all operations in the circuit. Thus, making a deep circuit take up more memory. However, it makes it straightforward to iteratively construct circuits. Furthermore, it supports the graphical interface for circuit construction <code>GUI.CircuitComposer!(circuit&lt;:FiniteDepthCircuit)</code>.</p><p>Usullay one would start with an empty circuit object for a given lattice</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">circuit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EmptyCircuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lattice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Lattice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>which can then be iteratively constructed. Adding an operation is as easy as calling</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, operation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vararg{Integer}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>where the number of arguments for <code>position</code> depends on the operation.</p><h3 id="randomcircuit" tabindex="-1">RandomCircuit <a class="header-anchor" href="#randomcircuit" aria-label="Permalink to &quot;RandomCircuit&quot;">​</a></h3><p>This type of circuit stores operations and possible positions together with probabilities. This results in a trade of, where the execution of the circuit takes longer, however deep circuits do not run out of memory. Since the structure of the circuit is random, there are no iterative construction capabilities.</p>',12),n=[r];function c(o,p,h,l,d,u){return e(),t("div",null,n)}const y=i(s,[["render",c]]);export{g as __pageData,y as default};
