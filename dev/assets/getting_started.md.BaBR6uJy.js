import{_ as i,c as t,o as s,a7 as a}from"./chunks/framework.Ck1NKG2X.js";const g=JSON.parse('{"title":"Getting Started","description":"","frontmatter":{},"headers":[],"relativePath":"getting_started.md","filePath":"getting_started.md","lastUpdated":null}'),e={name:"getting_started.md"},n=a(`<h1 id="Getting-Started" tabindex="-1">Getting Started <a class="header-anchor" href="#Getting-Started" aria-label="Permalink to &quot;Getting Started {#Getting-Started}&quot;">​</a></h1><p>The framework consists out of three main parts. First is the lattice, which represents the underlying qubits structure. Second is the circuit, which holds information about the operations applied to the qubits in a given lattice. The last part is the execution of the circuit, which can happen on various backends.</p><h2 id="lattice" tabindex="-1">Lattice <a class="header-anchor" href="#lattice" aria-label="Permalink to &quot;Lattice&quot;">​</a></h2><p>A <code>Lattice</code> is a representation of qubits and connections between them (i.e., a graph). In general, it is only possible to apply operations to multiple qubits if they are connected in the lattice. Ancillary qubits should also be explicitly represented in the lattice. Preimplemented lattices are</p><ul><li><p><code>HeavyChainLattice(length)</code></p></li><li><p><code>HeavySquareLattice(sizeX, sizeY)</code></p></li><li><p><code>HeavyHexagonLattice(sizeX, sizeY)</code></p></li><li><p><code>HexagonToricCodeLattice(sizeX, sizeY)</code></p></li></ul><p>To implement your own lattice, create a struct</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Mylattice </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MonitoredQuantumCircuits.Lattice</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    graph</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Graph</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isAncilla</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Bool}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # whether the qubit is an ancilla</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gridPositions</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Tuple{Int64,Int64}}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # the grid positions of the qubits for visualization</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>together with appropriate constructors. Optionally, a visualize function can be written</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> visualize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(io</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, lattice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Mylattice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # print a basic visualization of the lattice in the REPL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div><p>which results in a nicer CLI.</p><h2 id="circuit" tabindex="-1">Circuit <a class="header-anchor" href="#circuit" aria-label="Permalink to &quot;Circuit&quot;">​</a></h2><p>A circuit represents the operations being applied to the qubits in a lattice. As of now, there are two types of circuits</p><ul><li><p><code>FiniteDepthCircuit</code></p></li><li><p><code>RandomCircuit</code></p></li></ul><h3 id="finitedepthcircuit" tabindex="-1">FiniteDepthCircuit <a class="header-anchor" href="#finitedepthcircuit" aria-label="Permalink to &quot;FiniteDepthCircuit&quot;">​</a></h3><p>This type of circuit stores an explicit representation of all operations in the circuit. Thus, making a deep circuit take up more memory. However, it makes it straightforward to iteratively construct circuits. Furthermore, it supports the graphical interface for circuit construction <code>GUI.CircuitComposer!(circuit&lt;:FiniteDepthCircuit)</code>.</p><p>Usullay one would start with an empty circuit object for a given lattice</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">circuit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> EmptyCircuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(lattice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Lattice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>which can then be iteratively constructed. Adding an operation is as easy as calling</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">apply!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, operation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vararg{Integer}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>where the number of arguments for <code>position</code> depends on the operation.</p><h3 id="randomcircuit" tabindex="-1">RandomCircuit <a class="header-anchor" href="#randomcircuit" aria-label="Permalink to &quot;RandomCircuit&quot;">​</a></h3><p>This type of circuit stores operations and possible positions together with probabilities. This results in a trade of, where the execution of the circuit takes longer, however deep circuits do not run out of memory. Since the structure of the circuit is random, there are no iterative construction capabilities.</p><h2 id="execution" tabindex="-1">Execution <a class="header-anchor" href="#execution" aria-label="Permalink to &quot;Execution&quot;">​</a></h2><p>To execute a quantum circuit, one first has to think about which backend to use. Currently, there are the following backends:</p><ul><li><p>Quantum computer</p><ul><li>IBM Quantum</li></ul></li><li><p>Simulator</p><ul><li><p>Qiskit (Statevector, stabilizer, tensornetwork)</p></li><li><p>QuantumClifford (stabilizer, Pauli frame)</p></li></ul></li></ul><p>Now, one can execute the circuit using</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">execute!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, backend</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Backend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h1 id="Basic-API" tabindex="-1">Basic API <a class="header-anchor" href="#Basic-API" aria-label="Permalink to &quot;Basic API {#Basic-API}&quot;">​</a></h1>`,28),l=[n];function h(p,r,c,o,d,k){return s(),t("div",null,l)}const y=i(e,[["render",h]]);export{g as __pageData,y as default};
